1. 我会对解决问题的过程记录日志
2. 在解决完问题之后我会不时地回顾日志

日志：
词法分析：
    1. 对单引号和注释的处理
    2. 对16进制数的处理，这个要考虑若干情况，比如 "000x" "123x" "0 x" "0xyz"
    3. 对2进制数的处理，这里和原作者不太一样，我把 0b123 -> 1 23，原作者会直接报错
    4. 添加了对括号表达式的处理，nextc时放进buffer，token_create()会检测是否在表达式里，若是则token的指针指向它，目的未知
    5. 之前的词法分析是基于文件的，现在添加了一个基于字符串的lex函数，原作者的pushc有bug，已修改
    6. 给number加了一个类型，识别诸如 12L 123.0f 这种，但是不全，没有 long long 和 double，number 这个是有难度的。
    7. 从抽象意义上来说，lex_process只是生成token序列的，生成完之后还是要交给compile_process，但是词法分析就这样结束了吗？
        感觉这个此法分析还不完美，比如那个表达式缓冲区是干什么的，number的类型以及浮点数的问题还没解决。
    8. 新建一个”解析器“和一个新的结构node，这个node是干什么的，感觉和token很像。node中的信息可以指明该node属于哪个body,
        属于哪个函数。这个应该是要处理之前的括号表达式的问题，而且node还能识别当前的结构，比如if, while等等。这是语法分析吗？
    9. 新增了语法分析的框架和启动，其中 node_vec 和 node_tree_vec 存储的是 node 的指针。
    10. 创建了一些node相关的方法，他创建了node_vector和node_vector_root，前者存语法树的节点，后者存语法树的根节点。而且这
        个vector存的是node指针，因此一些细节上可能会不同，比如 ptr = *(struct node**)vector_back(node_vector)
        vector_back 返回指向最后一个元素的指针，如果存的元素也是指针，我们可以把返回值看成一个双重指针，所以 *返回值就是指向
        实际node的指针，这正是我们想要的。(不如说这个返回值本来就是struct node** 类型的)
    11. 目前做的事就是忽略换行，注释和反斜。然后对于数字，变量还有字符串token制作node，制作好的node被放入node_vec，然后将最新
        的node，也就是node_vec的最后一个值存进node_tree_vec，目前还不清楚node_vec和node_tree_vec的区别，但我估计node_t
        ree_vec是用来存储根节点的？
    12. 新增加了表达式node，将表达式序列看成一颗中序遍历的一棵树，将运算符看成是根节点，每次遇到运算符，就将左边的node当成左孩子，
        计算右边序列的语法树，并作为自己的右孩子。还有函数来检查一个node是否是表达式node，说明还有很多其他类型的node。指导了node
        _vec 和 node_tree_vec 的含义，node_vec 只是一个临时node数组，而 node_tree_vec 才是我们真正想要的，是语法树根节点的
        集合。
    13. 创建了一个用于表示优先级的结构，它把一类运算符放到一起，然后标注他们的优先级顺序，比如 a + b, 我肯定是先算出a的值，再算出
        b 的值，然后将它们相加，这就是从左到右。如果是 a = b，那么我肯定是先算出b的值，然后赋给a，这就是从右到左。再比如 a?b:c，
        这种条件转移语句，我肯定是先算出b和c，然后在根据a的值来返回。
    
日志简介： 
    1. 新增表达式node，将token序列看作语法树的中序序列
    2. 创建了表达语法树左右孩子的优先级集合，如a+b是先左后右，a=b是先右后左。